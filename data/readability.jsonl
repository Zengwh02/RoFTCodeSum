{"comments": "Build a normal attribute.", "code": "@SuppressWarnings({\"unchecked\"})\n\tpublic <X, Y> AttributeImplementor<X, Y> buildAttribute(AbstractManagedType<X> ownerType, Property property) {\n\t\tif ( property.isSynthetic() ) {\n\t\t\t// hide synthetic/virtual properties (fabricated by Hibernate) from the JPA metamodel.\n\t\t\tLOG.tracef( \"Skipping synthetic property %s(%s)\", ownerType.getTypeName(), property.getName() );\n\t\t\treturn null;\n\t\t}\n\t\tLOG.trace( \"Building attribute [\" + ownerType.getTypeName() + \".\" + property.getName() + \"]\" );\n\t\tfinal AttributeContext<X> attributeContext = wrap( ownerType, property );\n\t\tfinal AttributeMetadata<X, Y> attributeMetadata =\n\t\t\t\tdetermineAttributeMetadata( attributeContext, normalMemberResolver );\n\t\tif ( attributeMetadata == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( attributeMetadata.isPlural() ) {\n\t\t\treturn buildPluralAttribute( (PluralAttributeMetadata) attributeMetadata );\n\t\t}\n\t\tfinal SingularAttributeMetadata<X, Y> singularAttributeMetadata = (SingularAttributeMetadata<X, Y>) attributeMetadata;\n\t\tfinal Type<Y> metaModelType = getMetaModelType( singularAttributeMetadata.getValueContext() );\n\t\treturn new SingularAttributeImpl<X, Y>(\n\t\t\t\tattributeMetadata.getName(),\n\t\t\t\tattributeMetadata.getJavaType(),\n\t\t\t\townerType,\n\t\t\t\tattributeMetadata.getMember(),\n\t\t\t\tfalse,\n\t\t\t\tfalse,\n\t\t\t\tproperty.isOptional(),\n\t\t\t\tmetaModelType,\n\t\t\t\tattributeMetadata.getPersistentAttributeType()\n\t\t);\n\t}", "ref": "Build a normal attribute.", "readability": 2.888888888888889}
{"comments": "Loads the bundle (if not already loaded).", "code": "private static void loadBundle(String name) {\n        if (bundles.containsKey(name)) {\n            return;\n        }\n        String resource = BUNDLES_PATH + \".\" + name;\n        ResourceBundle bundle = null;\n        try {\n            LOG.debug(\"Loading \" + resource);\n            bundle = ResourceBundle.getBundle(resource, Locale.getDefault());\n        } catch (MissingResourceException e1) {\n            LOG.debug(\"Resource \" + resource\n\t\t      + \" not found in the default class loader.\");\n\n\t    Iterator iter = classLoaders.iterator();\n\t    while (iter.hasNext()) {\n\t\tClassLoader cl = (ClassLoader) iter.next();\n\t\ttry {\n\t\t    LOG.debug(\"Loading \" + resource + \" from \" + cl);\n\t\t    bundle =\n\t\t\tResourceBundle.getBundle(resource,\n\t\t\t\t\t\t Locale.getDefault(),\n\t\t\t\t\t\t cl);\n\t\t    break;\n\t\t} catch (MissingResourceException e2) {\n\t\t    LOG.debug(\"Resource \" + resource + \" not found in \" + cl);\n\t\t}\n\t    }\n        }\n\n        bundles.put(name, bundle);\n    }", "ref": "Loads the bundle (if not already loaded).", "readability": 3.0}
{"comments": "static initializer, register all appropriate notations.", "code": "static void init() {\n        NotationProviderFactory2 npf = NotationProviderFactory2.getInstance();\n        NotationName name = /*Notation.findNotation(\"Java\");*/\n            Notation.makeNotation(\n                    \"Java\",\n                    null,\n                    ResourceLoaderWrapper.lookupIconResource(\"JavaNotation\"));\n\n        npf.addNotationProvider(\n                NotationProviderFactory2.TYPE_NAME,\n                name, ModelElementNameNotationJava.class);\n        npf.addNotationProvider(\n                NotationProviderFactory2.TYPE_ATTRIBUTE,\n                name, AttributeNotationJava.class);\n        npf.addNotationProvider(\n                NotationProviderFactory2.TYPE_OPERATION,\n                name, OperationNotationJava.class);\n        npf.addNotationProvider(\n                NotationProviderFactory2.TYPE_ASSOCIATION_END_NAME,\n                name, AssociationEndNameNotationJava.class);\n        npf.addNotationProvider(\n                NotationProviderFactory2.TYPE_ASSOCIATION_NAME,\n                name, AssociationNameNotationJava.class);\n    }", "ref": "static initializer, register all appropriate notations.", "readability": 4.0}
{"comments": "Find an element in the list.", "code": "private static Checklist lookupChecklist(Class cls) {\n        if (lists.contains(cls)) {\n            return (Checklist) lists.get(cls);\n\t}\n\n        // Now lets search\n        Enumeration enumeration = lists.keys();\n\n        while (enumeration.hasMoreElements()) {\n            Object clazz = enumeration.nextElement();\n\n            Class[] intfs = cls.getInterfaces();\n            for (int i = 0; i < intfs.length; i++) {\n                if (intfs[i].equals(clazz)) {\n                    // We found it!\n                    Checklist chlist = (Checklist) lists.get(clazz);\n\n                    // Enter the class to speed up the next search.\n                    lists.put(cls, chlist);\n                    return chlist;\n                }\n            }\n        }\n\n        return null;\n    }", "ref": "Find an element in the list.", "readability": 4.0}
{"comments": "Constructs a SybaseASE157Dialect", "code": "public SybaseASE157Dialect() {\n\t\tsuper();\n\n\t\tregisterFunction( \"create_locator\", new SQLFunctionTemplate( StandardBasicTypes.BINARY, \"create_locator(?1, ?2)\" ) );\n\t\tregisterFunction( \"locator_literal\", new SQLFunctionTemplate( StandardBasicTypes.BINARY, \"locator_literal(?1, ?2)\" ) );\n\t\tregisterFunction( \"locator_valid\", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, \"locator_valid(?1)\" ) );\n\t\tregisterFunction( \"return_lob\", new SQLFunctionTemplate( StandardBasicTypes.BINARY, \"return_lob(?1, ?2)\" ) );\n\t\tregisterFunction( \"setdata\", new SQLFunctionTemplate( StandardBasicTypes.BOOLEAN, \"setdata(?1, ?2, ?3)\" ) );\n\t\tregisterFunction( \"charindex\", new SQLFunctionTemplate( StandardBasicTypes.INTEGER, \"charindex(?1, ?2, ?3)\" ) );\n\t}", "ref": "Constructs a SybaseASE157Dialect", "readability": 4.0}
{"comments": "Perform {@link org.hibernate.action.spi.Executable#execute()} on each element of the list", "code": "private <E extends Executable & Comparable<?> & Serializable> void executeActions(ExecutableList<E> list) throws HibernateException {\n\t\t// todo : consider ways to improve the double iteration of Executables here:\n\t\t//\t\t1) we explicitly iterate list here to perform Executable#execute()\n\t\t//\t\t2) ExecutableList#getQuerySpaces also iterates the Executables to collect query spaces.\n\t\ttry {\n\t\t\tfor ( E e : list ) {\n\t\t\t\ttry {\n\t\t\t\t\te.execute();\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tbeforeTransactionProcesses.register( e.getBeforeTransactionCompletionProcess() );\n\t\t\t\t\tafterTransactionProcesses.register( e.getAfterTransactionCompletionProcess() );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tif ( session.getFactory().getSettings().isQueryCacheEnabled() ) {\n\t\t\t\t// Strictly speaking, only a subset of the list may have been processed if a RuntimeException occurs.\n\t\t\t\t// We still invalidate all spaces. I don't see this as a big deal - after all, RuntimeExceptions are\n\t\t\t\t// unexpected.\n\t\t\t\tSet<Serializable> propertySpaces = list.getQuerySpaces();\n\t\t\t\tinvalidateSpaces( propertySpaces.toArray( new Serializable[propertySpaces.size()] ) );\n\t\t\t}\n\t\t}\n\n\t\tlist.clear();\n\t\tsession.getTransactionCoordinator().getJdbcCoordinator().executeBatch();\n\t}", "ref": "Perform {@link org.hibernate.action.spi.Executable#execute()} on each element of the list", "readability": 3.5555555555555554}
{"comments": "Constructs a PostgresPlusDialect", "code": "public PostgresPlusDialect() {\n\t\tsuper();\n\n\t\tregisterFunction( \"ltrim\", new StandardSQLFunction( \"ltrim\" ) );\n\t\tregisterFunction( \"rtrim\", new StandardSQLFunction( \"rtrim\" ) );\n\t\tregisterFunction( \"soundex\", new StandardSQLFunction( \"soundex\" ) );\n\t\tregisterFunction( \"sysdate\", new NoArgSQLFunction( \"sysdate\", StandardBasicTypes.DATE, false ) );\n\t\tregisterFunction( \"rowid\", new NoArgSQLFunction( \"rowid\", StandardBasicTypes.LONG, false ) );\n\t\tregisterFunction( \"rownum\", new NoArgSQLFunction( \"rownum\", StandardBasicTypes.LONG, false ) );\n\t\tregisterFunction( \"instr\", new StandardSQLFunction( \"instr\", StandardBasicTypes.INTEGER ) );\n\t\tregisterFunction( \"lpad\", new StandardSQLFunction( \"lpad\", StandardBasicTypes.STRING ) );\n\t\tregisterFunction( \"replace\", new StandardSQLFunction( \"replace\", StandardBasicTypes.STRING ) );\n\t\tregisterFunction( \"rpad\", new StandardSQLFunction( \"rpad\", StandardBasicTypes.STRING ) );\n\t\tregisterFunction( \"translate\", new StandardSQLFunction( \"translate\", StandardBasicTypes.STRING ) );\n\t\tregisterFunction( \"substring\", new StandardSQLFunction( \"substr\", StandardBasicTypes.STRING ) );\n\t\tregisterFunction( \"coalesce\", new NvlFunction() );\n\t\tregisterFunction( \"atan2\", new StandardSQLFunction( \"atan2\", StandardBasicTypes.FLOAT ) );\n\t\tregisterFunction( \"mod\", new StandardSQLFunction( \"mod\", StandardBasicTypes.INTEGER ) );\n\t\tregisterFunction( \"nvl\", new StandardSQLFunction( \"nvl\" ) );\n\t\tregisterFunction( \"nvl2\", new StandardSQLFunction( \"nvl2\" ) );\n\t\tregisterFunction( \"power\", new StandardSQLFunction( \"power\", StandardBasicTypes.FLOAT ) );\n\t\tregisterFunction( \"add_months\", new StandardSQLFunction( \"add_months\", StandardBasicTypes.DATE ) );\n\t\tregisterFunction( \"months_between\", new StandardSQLFunction( \"months_between\", StandardBasicTypes.FLOAT ) );\n\t\tregisterFunction( \"next_day\", new StandardSQLFunction( \"next_day\", StandardBasicTypes.DATE ) );\n\t}", "ref": "Constructs a PostgresPlusDialect", "readability": 4.0}
{"comments": "Handle sending notifications needed for natural-id after saving", "code": "public void handleNaturalIdPostSaveNotifications(Serializable generatedId) {\n\t\tif ( isEarlyInsert() ) {\n\t\t\t// with early insert, we still need to add a local (transactional) natural id cross-reference\n\t\t\tgetSession().getPersistenceContext().getNaturalIdHelper().manageLocalNaturalIdCrossReference(\n\t\t\t\t\tgetPersister(),\n\t\t\t\t\tgeneratedId,\n\t\t\t\t\tstate,\n\t\t\t\t\tnull,\n\t\t\t\t\tCachedNaturalIdValueSource.INSERT\n\t\t\t);\n\t\t}\n\t\t// after save, we need to manage the shared cache entries\n\t\tgetSession().getPersistenceContext().getNaturalIdHelper().manageSharedNaturalIdCrossReference(\n\t\t\t\tgetPersister(),\n\t\t\t\tgetId(),\n\t\t\t\tstate,\n\t\t\t\tnull,\n\t\t\t\tCachedNaturalIdValueSource.INSERT\n\t\t);\n\t}", "ref": "Handle sending notifications needed for natural-id after saving", "readability": 3.888888888888889}
{"comments": "Get the value mapped to this key, or null if no value is mapped to this key.", "code": "public final Object get(Object key) {\n\t\ttry {\n\t\t\tfinal Element element = getCache().get( key );\n\t\t\tif ( element == null ) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn element.getObjectValue();\n\t\t\t}\n\t\t}\n\t\tcatch (net.sf.ehcache.CacheException e) {\n\t\t\tif ( e instanceof NonStopCacheException ) {\n\t\t\t\tHibernateNonstopCacheExceptionHandler.getInstance()\n\t\t\t\t\t\t.handleNonstopCacheException( (NonStopCacheException) e );\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthrow new CacheException( e );\n\t\t\t}\n\t\t}\n\t}", "ref": "Get the value mapped to this key, or null if no value is mapped to this key.", "readability": 4.222222222222222}
{"comments": "Provides serialization support.", "code": "private void readObject(ObjectInputStream stream)\n        throws IOException, ClassNotFoundException {\n        stream.defaultReadObject();\n        this.titlePaint = SerialUtilities.readPaint(stream);\n        this.subtitlePaint = SerialUtilities.readPaint(stream);\n        this.chartBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.legendBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.legendItemPaint = SerialUtilities.readPaint(stream);\n        this.plotBackgroundPaint = SerialUtilities.readPaint(stream);\n        this.plotOutlinePaint = SerialUtilities.readPaint(stream);\n        this.labelLinkPaint = SerialUtilities.readPaint(stream);\n        this.baselinePaint = SerialUtilities.readPaint(stream);\n        this.domainGridlinePaint = SerialUtilities.readPaint(stream);\n        this.rangeGridlinePaint = SerialUtilities.readPaint(stream);\n        this.crosshairPaint = SerialUtilities.readPaint(stream);\n        this.axisLabelPaint = SerialUtilities.readPaint(stream);\n        this.tickLabelPaint = SerialUtilities.readPaint(stream);\n        this.itemLabelPaint = SerialUtilities.readPaint(stream);\n        this.shadowPaint = SerialUtilities.readPaint(stream);\n        this.thermometerPaint = SerialUtilities.readPaint(stream);\n        this.wallPaint = SerialUtilities.readPaint(stream);\n        this.errorIndicatorPaint = SerialUtilities.readPaint(stream);\n        this.gridBandPaint = SerialUtilities.readPaint(stream);\n        this.gridBandAlternatePaint = SerialUtilities.readPaint(stream);\n    }", "ref": "Provides serialization support.", "readability": 3.5555555555555554}
{"comments": "Tests another object for equality with this object.", "code": "@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof PinNeedle)) {\n            return false;\n        }\n        if (!super.equals(obj)) {\n            return false;\n        }\n        return true;\n    }", "ref": "Tests another object for equality with this object.", "readability": 4.777777777777778}
{"comments": "Interpret a long as its binary form", "code": "public static byte[] fromLong(long longValue) {\n\t\tbyte[] bytes = new byte[8];\n\t\tbytes[0] = (byte) ( longValue >> 56 );\n\t\tbytes[1] = (byte) ( ( longValue << 8 ) >> 56 );\n\t\tbytes[2] = (byte) ( ( longValue << 16 ) >> 56 );\n\t\tbytes[3] = (byte) ( ( longValue << 24 ) >> 56 );\n\t\tbytes[4] = (byte) ( ( longValue << 32 ) >> 56 );\n\t\tbytes[5] = (byte) ( ( longValue << 40 ) >> 56 );\n\t\tbytes[6] = (byte) ( ( longValue << 48 ) >> 56 );\n\t\tbytes[7] = (byte) ( ( longValue << 56 ) >> 56 );\n\t\treturn bytes;\n\t}", "ref": "Interpret a long as its binary form", "readability": 4.111111111111111}
{"comments": "Build the metamodel using the information from the collection of Hibernate", "code": "public static MetamodelImpl buildMetamodel(\n\t\t\tIterator<PersistentClass> persistentClasses,\n\t\t\tSet<MappedSuperclass> mappedSuperclasses,\n\t\t\tSessionFactoryImplementor sessionFactory,\n            boolean ignoreUnsupported) {\n\t\tMetadataContext context = new MetadataContext( sessionFactory, mappedSuperclasses, ignoreUnsupported );\n\t\twhile ( persistentClasses.hasNext() ) {\n\t\t\tPersistentClass pc = persistentClasses.next();\n\t\t\tlocateOrBuildEntityType( pc, context );\n\t\t}\n\t\thandleUnusedMappedSuperclasses( context );\n\t\tcontext.wrapUp();\n\t\treturn new MetamodelImpl( context.getEntityTypeMap(), context.getEmbeddableTypeMap(), context.getMappedSuperclassTypeMap(), context.getEntityTypesByEntityName() );\n\t}", "ref": "Build the metamodel using the information from the collection of Hibernate", "readability": 3.111111111111111}
{"comments": "Build a ParameterMemento from the given parameter registration", "code": "public static ParameterMemento fromRegistration(ParameterRegistrationImplementor registration) {\n\t\t\treturn new ParameterMemento(\n\t\t\t\t\tregistration.getPosition(),\n\t\t\t\t\tregistration.getName(),\n\t\t\t\t\tregistration.getMode(),\n\t\t\t\t\tregistration.getType(),\n\t\t\t\t\tregistration.getHibernateType()\n\t\t\t);\n\t\t}", "ref": "Build a ParameterMemento from the given parameter registration", "readability": 4.666666666666667}
{"comments": "Tests this instance for equality with an arbitrary object.", "code": "@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof OHLC)) {\n            return false;\n        }\n        OHLC that = (OHLC) obj;\n        if (this.open != that.open) {\n            return false;\n        }\n        if (this.close != that.close) {\n            return false;\n        }\n        if (this.high != that.high) {\n            return false;\n        }\n        if (this.low != that.low) {\n            return false;\n        }\n        return true;\n    }", "ref": "Tests this instance for equality with an arbitrary object.", "readability": 4.666666666666667}
{"comments": "The constructor.", "code": "public TabChecklist() {\n\tsuper(\"tab.checklist\");\n\n\ttableModel = new TableModelChecklist(this);\n\ttable.setModel(tableModel);\n\n\tFont labelFont = LookAndFeelMgr.getInstance().getStandardFont();\n\ttable.setFont(labelFont);\n\n\ttable.setIntercellSpacing(new Dimension(0, 1));\n\ttable.setShowVerticalLines(false);\n\ttable.getSelectionModel().addListSelectionListener(this);\n\ttable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);\n\n\tTableColumn checkCol = table.getColumnModel().getColumn(0);\n\tTableColumn descCol = table.getColumnModel().getColumn(1);\n\tcheckCol.setMinWidth(20);\n\tcheckCol.setMaxWidth(30);\n\tcheckCol.setWidth(30);\n\tdescCol.setPreferredWidth(900);\n\ttable.setAutoResizeMode(JTable.AUTO_RESIZE_LAST_COLUMN);\n\ttable.sizeColumnsToFit(-1);\n\n\tJScrollPane sp = new JScrollPane(table);\n\n\tsetLayout(new BorderLayout());\n\tadd(new JLabel(Translator.localize(\"tab.checklist.warning\")),\n\t    BorderLayout.NORTH);\n\tadd(sp, BorderLayout.CENTER);\n\t\n\taddComponentListener(this);\n    }", "ref": "The constructor.", "readability": 3.888888888888889}
{"comments": "Delete an object", "code": "public void delete(Serializable id, Object version, Object object, SessionImplementor session)\n\t\t\tthrows HibernateException {\n\t\tfinal int span = getTableSpan();\n\t\tboolean isImpliedOptimisticLocking = !entityMetamodel.isVersioned() && isAllOrDirtyOptLocking();\n\t\tObject[] loadedState = null;\n\t\tif ( isImpliedOptimisticLocking ) {\n\t\t\t// need to treat this as if it where optimistic-lock=\"all\" (dirty does *not* make sense);\n\t\t\t// first we need to locate the \"loaded\" state\n\t\t\t//\n\t\t\t// Note, it potentially could be a proxy, so doAfterTransactionCompletion the location the safe way...\n\t\t\tfinal EntityKey key = session.generateEntityKey( id, this );\n\t\t\tObject entity = session.getPersistenceContext().getEntity( key );\n\t\t\tif ( entity != null ) {\n\t\t\t\tEntityEntry entry = session.getPersistenceContext().getEntry( entity );\n\t\t\t\tloadedState = entry.getLoadedState();\n\t\t\t}\n\t\t}\n\n\t\tfinal String[] deleteStrings;\n\t\tif ( isImpliedOptimisticLocking && loadedState != null ) {\n\t\t\t// we need to utilize dynamic delete statements\n\t\t\tdeleteStrings = generateSQLDeletStrings( loadedState );\n\t\t}\n\t\telse {\n\t\t\t// otherwise, utilize the static delete statements\n\t\t\tdeleteStrings = getSQLDeleteStrings();\n\t\t}\n\n\t\tfor ( int j = span - 1; j >= 0; j-- ) {\n\t\t\tdelete( id, version, j, object, deleteStrings[j], session, loadedState );\n\t\t}\n\n\t}", "ref": "Delete an object", "readability": 3.5555555555555554}
{"comments": "Constructs a FrontBaseDialect", "code": "public FrontBaseDialect() {\n\t\tsuper();\n\n\t\tregisterColumnType( Types.BIT, \"bit\" );\n\t\tregisterColumnType( Types.BIGINT, \"longint\" );\n\t\tregisterColumnType( Types.SMALLINT, \"smallint\" );\n\t\tregisterColumnType( Types.TINYINT, \"tinyint\" );\n\t\tregisterColumnType( Types.INTEGER, \"integer\" );\n\t\tregisterColumnType( Types.CHAR, \"char(1)\" );\n\t\tregisterColumnType( Types.VARCHAR, \"varchar($l)\" );\n\t\tregisterColumnType( Types.FLOAT, \"float\" );\n\t\tregisterColumnType( Types.DOUBLE, \"double precision\" );\n\t\tregisterColumnType( Types.DATE, \"date\" );\n\t\tregisterColumnType( Types.TIME, \"time\" );\n\t\tregisterColumnType( Types.TIMESTAMP, \"timestamp\" );\n\t\tregisterColumnType( Types.VARBINARY, \"bit varying($l)\" );\n\t\tregisterColumnType( Types.NUMERIC, \"numeric($p,$s)\" );\n\t\tregisterColumnType( Types.BLOB, \"blob\" );\n\t\tregisterColumnType( Types.CLOB, \"clob\" );\n\t}", "ref": "Constructs a FrontBaseDialect", "readability": 4.222222222222222}
{"comments": "Constructs a Oracle8iDialect", "code": "public Oracle8iDialect() {\n\t\tsuper();\n\t\tregisterCharacterTypeMappings();\n\t\tregisterNumericTypeMappings();\n\t\tregisterDateTimeTypeMappings();\n\t\tregisterLargeObjectTypeMappings();\n\t\tregisterReverseHibernateTypeMappings();\n\t\tregisterFunctions();\n\t\tregisterDefaultProperties();\n\t}", "ref": "Constructs a Oracle8iDialect", "readability": 4.0}
{"comments": "Displays visual indications of pending ToDoItems.", "code": "public void paintClarifiers(Graphics g) {\n        int iconX = getX();\n        int iconY = getY() - 10;\n        ToDoList list = Designer.theDesigner().getToDoList();\n        Vector items = list.elementsForOffender(getOwner());\n        int size = items.size();\n        for (int i = 0; i < size; i++) {\n            ToDoItem item = (ToDoItem) items.elementAt(i);\n            Icon icon = item.getClarifier();\n            if (icon instanceof Clarifier) {\n                ((Clarifier) icon).setFig(this);\n                ((Clarifier) icon).setToDoItem(item);\n            }\n            if (icon != null) {\n                icon.paintIcon(null, g, iconX, iconY);\n                iconX += icon.getIconWidth();\n            }\n        }\n        items = list.elementsForOffender(this);\n        size = items.size();\n        for (int i = 0; i < size; i++) {\n            ToDoItem item = (ToDoItem) items.elementAt(i);\n            Icon icon = item.getClarifier();\n            if (icon instanceof Clarifier) {\n                ((Clarifier) icon).setFig(this);\n                ((Clarifier) icon).setToDoItem(item);\n            }\n            if (icon != null) {\n                icon.paintIcon(null, g, iconX, iconY);\n                iconX += icon.getIconWidth();\n            }\n        }\n    }", "ref": "Displays visual indications of pending ToDoItems.", "readability": 3.3333333333333335}
{"comments": "Verifies that listeners added with addFirstListener() while tests are run concurrently are notified about test failures.", "code": "@Test\n    public void reportConcurrentFailuresAfterAddFirstListener() throws Exception {\n        new AbstractConcurrentFailuresTest() {\n            @Override\n            protected void addListener(ExaminedListener listener) {\n                fNotifier.addFirstListener(listener);\n            }\n        }.test();\n    }", "ref": "Verifies that listeners added with addFirstListener() while tests are run concurrently are notified about test failures.", "readability": 4.222222222222222}
{"comments": "Execute given <tt>PreparedStatement</tt>, advance to the first result and return SQL <tt>ResultSet</tt>.", "code": "protected final ResultSet getResultSet(\n\t\t\tfinal PreparedStatement st,\n\t\t\tfinal RowSelection selection,\n\t\t\tfinal LimitHandler limitHandler,\n\t\t\tfinal boolean autodiscovertypes,\n\t\t\tfinal SessionImplementor session)\n\tthrows SQLException, HibernateException {\n\n\t\ttry {\n\t\t\tResultSet rs = session.getTransactionCoordinator().getJdbcCoordinator().getResultSetReturn().extract( st );\n\t\t\trs = wrapResultSetIfEnabled( rs , session );\n\n\t\t\tif ( !limitHandler.supportsLimitOffset() || !LimitHelper.useLimit( limitHandler, selection ) ) {\n\t\t\t\tadvance( rs, selection );\n\t\t\t}\n\n\t\t\tif ( autodiscovertypes ) {\n\t\t\t\tautoDiscoverTypes( rs );\n\t\t\t}\n\t\t\treturn rs;\n\t\t}\n\t\tcatch ( SQLException sqle ) {\n\t\t\tsession.getTransactionCoordinator().getJdbcCoordinator().release( st );\n\t\t\tthrow sqle;\n\t\t}\n\t}", "ref": "Execute given <tt>PreparedStatement</tt>, advance to the first result and return SQL <tt>ResultSet</tt>.", "readability": 4.0}
{"comments": "Constructs a InterbaseDialect", "code": "public InterbaseDialect() {\n\t\tsuper();\n\t\tregisterColumnType( Types.BIT, \"smallint\" );\n\t\tregisterColumnType( Types.BIGINT, \"numeric(18,0)\" );\n\t\tregisterColumnType( Types.SMALLINT, \"smallint\" );\n\t\tregisterColumnType( Types.TINYINT, \"smallint\" );\n\t\tregisterColumnType( Types.INTEGER, \"integer\" );\n\t\tregisterColumnType( Types.CHAR, \"char(1)\" );\n\t\tregisterColumnType( Types.VARCHAR, \"varchar($l)\" );\n\t\tregisterColumnType( Types.FLOAT, \"float\" );\n\t\tregisterColumnType( Types.DOUBLE, \"double precision\" );\n\t\tregisterColumnType( Types.DATE, \"date\" );\n\t\tregisterColumnType( Types.TIME, \"time\" );\n\t\tregisterColumnType( Types.TIMESTAMP, \"timestamp\" );\n\t\tregisterColumnType( Types.VARBINARY, \"blob\" );\n\t\tregisterColumnType( Types.NUMERIC, \"numeric($p,$s)\" );\n\t\tregisterColumnType( Types.BLOB, \"blob\" );\n\t\tregisterColumnType( Types.CLOB, \"blob sub_type 1\" );\n\t\tregisterColumnType( Types.BOOLEAN, \"smallint\" );\n\t\t\n\t\tregisterFunction( \"concat\", new VarArgsSQLFunction( StandardBasicTypes.STRING, \"(\",\"||\",\")\" ) );\n\t\tregisterFunction( \"current_date\", new NoArgSQLFunction( \"current_date\", StandardBasicTypes.DATE, false ) );\n\n\t\tgetDefaultProperties().setProperty( Environment.STATEMENT_BATCH_SIZE, NO_BATCH );\n\t}", "ref": "Constructs a InterbaseDialect", "readability": 3.888888888888889}
{"comments": "Tests the equality of this object against an arbitrary Object.", "code": "@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Second)) {\n            return false;\n        }\n        Second that = (Second) obj;\n        if (this.second != that.second) {\n            return false;\n        }\n        if (this.minute != that.minute) {\n            return false;\n        }\n        if (this.hour != that.hour) {\n            return false;\n        }\n        if (!this.day.equals(that.day)) {\n            return false;\n        }\n        return true;\n    }", "ref": "Tests the equality of this object against an arbitrary Object.", "readability": 4.666666666666667}
{"comments": "add statistics report of a DB query", "code": "void executed(long rows, long time) {\n\t\t// read lock is enough, concurrent updates are supported by the underlying type AtomicLong\n\t\t// this only guards executed(long, long) to be called, when another thread is executing getExecutionAvgTime()\n\t\treadLock.lock();\n\t\ttry {\n\t\t\t// Less chances for a context switch\n\t\t\tfor (long old = executionMinTime.get(); (time < old) && !executionMinTime.compareAndSet(old, time); old = executionMinTime.get());\n\t\t\tfor (long old = executionMaxTime.get(); (time > old) && !executionMaxTime.compareAndSet(old, time); old = executionMaxTime.get());\n\t\t\texecutionCount.getAndIncrement();\n\t\t\texecutionRowCount.addAndGet(rows);\n\t\t\ttotalExecutionTime.addAndGet(time);\n\t\t} finally {\n\t\t\treadLock.unlock();\n\t\t}\n\t}", "ref": "add statistics report of a DB query", "readability": 3.3333333333333335}
{"comments": "Retrieves a PropertyAccessor instance based on the given property definition and", "code": "public static PropertyAccessor getPropertyAccessor(AttributeBinding property, EntityMode mode) throws MappingException {\n\t\t//TODO: this is temporary in that the end result will probably not take a Property reference per-se.\n\t    if ( null == mode || EntityMode.POJO.equals( mode ) ) {\n\t\t    return getPojoPropertyAccessor( property.getPropertyAccessorName() );\n\t    }\n\t    else if ( EntityMode.MAP.equals( mode ) ) {\n\t\t    return getDynamicMapPropertyAccessor();\n\t    }\n\t    else {\n\t\t    throw new MappingException( \"Unknown entity mode [\" + mode + \"]\" );\n\t    }\n\t}", "ref": "Retrieves a PropertyAccessor instance based on the given property definition and", "readability": 4.333333333333333}
{"comments": "Provides serialization support.", "code": "private void writeObject(ObjectOutputStream stream) throws IOException {\n        stream.defaultWriteObject();\n\n        SerialUtilities.writeShape(this.legendItemShape, stream);\n        SerialUtilities.writePaint(this.seriesPaint, stream);\n        SerialUtilities.writePaint(this.baseSeriesPaint, stream);\n        SerialUtilities.writePaint(this.seriesOutlinePaint, stream);\n        SerialUtilities.writePaint(this.baseSeriesOutlinePaint, stream);\n        SerialUtilities.writeStroke(this.seriesOutlineStroke, stream);\n        SerialUtilities.writeStroke(this.baseSeriesOutlineStroke, stream);\n        SerialUtilities.writePaint(this.labelPaint, stream);\n        SerialUtilities.writePaint(this.axisLinePaint, stream);\n        SerialUtilities.writeStroke(this.axisLineStroke, stream);\n    }", "ref": "Provides serialization support.", "readability": 4.222222222222222}
{"comments": "Constructs a panel that displays the specified chart.", "code": "public ChartPanel(JFreeChart chart) {\n\n        this(\n            chart,\n            DEFAULT_WIDTH,\n            DEFAULT_HEIGHT,\n            DEFAULT_MINIMUM_DRAW_WIDTH,\n            DEFAULT_MINIMUM_DRAW_HEIGHT,\n            DEFAULT_MAXIMUM_DRAW_WIDTH,\n            DEFAULT_MAXIMUM_DRAW_HEIGHT,\n            DEFAULT_BUFFER_USED,\n            true,  // properties\n            true,  // save\n            true,  // print\n            true,  // zoom\n            true   // tooltips\n        );\n\n    }", "ref": "Constructs a panel that displays the specified chart.", "readability": 4.333333333333333}
{"comments": "Tests this dataset for equality with an arbitrary object.", "code": "@Override\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof CategoryDataset)) {\n            return false;\n        }\n        CategoryDataset that = (CategoryDataset) obj;\n        if (!getRowKeys().equals(that.getRowKeys())) {\n            return false;\n        }\n        if (!getColumnKeys().equals(that.getColumnKeys())) {\n            return false;\n        }\n        int rowCount = getRowCount();\n        int colCount = getColumnCount();\n        for (int r = 0; r < rowCount; r++) {\n            for (int c = 0; c < colCount; c++) {\n                Number v1 = getValue(r, c);\n                Number v2 = that.getValue(r, c);\n                if (v1 == null) {\n                    if (v2 != null) {\n                        return false;\n                    }\n                }\n                else if (!v1.equals(v2)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }", "ref": "Tests this dataset for equality with an arbitrary object.", "readability": 4.222222222222222}
{"comments": "Saves the given actions in the configuration file", "code": "public static void saveShortcuts(Action[] newActions) {\n        for (int i = 0; i < newActions.length; i++) {\n            Action oldAction = (Action) shortcutHash\n                    .get(newActions[i].getKey());\n            if (newActions[i].getCurrentShortcut() == null\n                    && newActions[i].getDefaultShortcut() != null) {\n                // if a default action was voided then we have to save it\n                Configuration.setString(Configuration.makeKey(oldAction\n                        .getKey()), \"\");\n            } else if (newActions[i].getCurrentShortcut() != null\n                    && !newActions[i].getCurrentShortcut().equals(\n                            newActions[i].getDefaultShortcut())) {\n                // if a not-default current shortcut was added, then we have to\n                // save it\n                Configuration.setString(Configuration.makeKey(oldAction\n                        .getKey()), KeyEventUtils.formatKeyStroke(newActions[i]\n                        .getCurrentShortcut()));\n            } else {\n                // if the actual is not going to be saved, then try to remove it\n                // (as it could have been cancelled)\n                Configuration.removeKey(Configuration.makeKey(oldAction\n                        .getKey()));\n            }\n        }\n    }", "ref": "Saves the given actions in the configuration file", "readability": 3.4444444444444446}
{"comments": "Returns the minimum and maximum values for the dataset's range", "code": "public static Range findStackedRangeBounds(CategoryDataset dataset,\n            double base) {\n        ParamChecks.nullNotPermitted(dataset, \"dataset\");\n        Range result = null;\n        double minimum = Double.POSITIVE_INFINITY;\n        double maximum = Double.NEGATIVE_INFINITY;\n        int categoryCount = dataset.getColumnCount();\n        for (int item = 0; item < categoryCount; item++) {\n            double positive = base;\n            double negative = base;\n            int seriesCount = dataset.getRowCount();\n            for (int series = 0; series < seriesCount; series++) {\n                Number number = dataset.getValue(series, item);\n                if (number != null) {\n                    double value = number.doubleValue();\n                    if (value > 0.0) {\n                        positive = positive + value;\n                    }\n                    if (value < 0.0) {\n                        negative = negative + value;\n                        // '+', remember value is negative\n                    }\n                }\n            }\n            minimum = Math.min(minimum, negative);\n            maximum = Math.max(maximum, positive);\n        }\n        if (minimum <= maximum) {\n            result = new Range(minimum, maximum);\n        }\n        return result;\n\n    }", "ref": "Returns the minimum and maximum values for the dataset's range", "readability": 4.111111111111111}
{"comments": "Notify all listeners that have registered interest for notification on this event type.", "code": "public void fireTreeStructureChanged(\n\t\t\t\t\t Object source,\n\t\t\t\t\t Object[] path,\n\t\t\t\t\t int[] childIndices,\n\t\t\t\t\t Object[] children) {\n\n        // Guaranteed to return a non-null array\n        Object[] listeners = listenerList.getListenerList();\n        TreeModelEvent e = null;\n        // Process the listeners last to first, notifying\n        // those that are interested in this event\n        for (int i = listeners.length - 2; i >= 0; i -= 2) {\n            if (listeners[i] == TreeModelListener.class) {\n                // Lazily create the event:\n                if (e == null)\n                    e =\n                        new TreeModelEvent(\n\t\t\t\t\t   source,\n\t\t\t\t\t   path,\n\t\t\t\t\t   childIndices,\n\t\t\t\t\t   children);\n                ((TreeModelListener) listeners[i + 1]).treeStructureChanged(e);\n            }\n        }\n    }", "ref": "Notify all listeners that have registered interest for notification on this event type.", "readability": 3.7777777777777777}
{"comments": "Generate a select list of columns containing all properties of the entity classes", "code": "protected final String selectString(List associations)\n\tthrows MappingException {\n\n\t\tif ( associations.size()==0 ) {\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\tStringBuilder buf = new StringBuilder( associations.size() * 100 );\n\t\t\tint entityAliasCount=0;\n\t\t\tint collectionAliasCount=0;\n\t\t\tfor ( int i=0; i<associations.size(); i++ ) {\n\t\t\t\tOuterJoinableAssociation join = (OuterJoinableAssociation) associations.get(i);\n\t\t\t\tOuterJoinableAssociation next = (i == associations.size() - 1)\n\t\t\t\t        ? null\n\t\t\t\t        : ( OuterJoinableAssociation ) associations.get( i + 1 );\n\t\t\t\tfinal Joinable joinable = join.getJoinable();\n\t\t\t\tfinal String entitySuffix = ( suffixes == null || entityAliasCount >= suffixes.length )\n\t\t\t\t        ? null\n\t\t\t\t        : suffixes[entityAliasCount];\n\t\t\t\tfinal String collectionSuffix = ( collectionSuffixes == null || collectionAliasCount >= collectionSuffixes.length )\n\t\t\t\t        ? null\n\t\t\t\t        : collectionSuffixes[collectionAliasCount];\n\t\t\t\tfinal String selectFragment = joinable.selectFragment(\n\t\t\t\t\t\tnext == null ? null : next.getJoinable(),\n\t\t\t\t\t\tnext == null ? null : next.getRHSAlias(),\n\t\t\t\t\t\tjoin.getRHSAlias(),\n\t\t\t\t\t\tentitySuffix,\n\t\t\t\t        collectionSuffix,\n\t\t\t\t\t\tjoin.getJoinType()==JoinType.LEFT_OUTER_JOIN\n\t\t\t\t);\n\t\t\t\tif (selectFragment.trim().length() > 0) {\n\t\t\t\t\tbuf.append(\", \").append(selectFragment);\n\t\t\t\t}\n\t\t\t\tif ( joinable.consumesEntityAlias() ) entityAliasCount++;\n\t\t\t\tif ( joinable.consumesCollectionAlias() && join.getJoinType()==JoinType.LEFT_OUTER_JOIN ) collectionAliasCount++;\n\t\t\t}\n\t\t\treturn buf.toString();\n\t\t}\n\t}", "ref": "Generate a select list of columns containing all properties of the entity classes", "readability": 2.5555555555555554}
{"comments": "Construct a property panel for Node Instance elements.", "code": "public PropPanelNodeInstance() {\n        super(\"Node Instance\", lookupIcon(\"NodeInstance\"),\n                ConfigLoader.getTabPropsOrientation());\n\n        addField(Translator.localize(\"label.name\"), getNameTextField());\n        addField(Translator.localize(\"label.namespace\"),\n                getNamespaceSelector());\n\n        addSeparator();\n\n        addField(Translator.localize(\"label.stimili-sent\"),\n                getStimuliSenderScroll());\n\n        addField(Translator.localize(\"label.stimili-received\"),\n                getStimuliReceiverScroll());\n\n        JList resList = new UMLLinkedList(new UMLContainerResidentListModel());\n        addField(Translator.localize(\"label.residents\"),\n                new JScrollPane(resList));\n\n        addSeparator();\n        AbstractActionAddModelElement a =\n            new ActionAddInstanceClassifier(Model.getMetaTypes().getNode());\n        JScrollPane classifierScroll =\n                new JScrollPane(new UMLMutableLinkedList(\n\t                new UMLInstanceClassifierListModel(),\n\t            a, null, null, true));\n\taddField(Translator.localize(\"label.classifiers\"),\n                    classifierScroll);\n\n\n        addAction(new ActionNavigateContainerElement());\n        addAction(new ActionNewStereotype());\n        addAction(getDeleteAction());\n    }", "ref": "Construct a property panel for Node Instance elements.", "readability": 2.6666666666666665}
